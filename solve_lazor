class Solution:
    # find the solution of the lazor problem

    def __init__(self, grid, x_dimension, y_dimension):
        self.grid = grid
        self.x_dimension = x_dimension
        self.y_dimension = y_dimension

        # number of blocks in each type
        self.a = None
        self.b = None
        self.c = None

    def chk_lazor(self, position):

        '''
        This function checks whether the lazor can pass the point

        parameters:

            position: *tuple*
                the coordinates of a point

        returns:

            *bool*
            True if lazor can pass otherwise False
        '''
        pos_x = position[0]
        pos_y = position[1]

        if self.grid[pos_x][pos_y] != 0:
            return False

        x_dimension = self.x_dimension
        y_dimension = self.y_dimension

        return (0 <= pos_x <= x_dimension) and (0 <= pos_y <= y_dimension)
        
    
    def chk_block(self, position):

        '''
        This funciton check whether the block can be placed in this position

        parameters:

            position: *tuple*
                the coordinates of a block

        returns:

            *bool*
            True if block can be placed otherwise False
        '''

        pos_x = position[0]
        pos_y = position[1]

        if self.grid[pos_x][pos_y] == 1:
            return True
        else: return False


    def path(self, lasor_position, lasor_direction):

        '''
        This function calculates the lazor path and blocks accordingly given a laser point

        parameters:

            lasor_position: *tuple*
                coordinates of lazor point
            
            lasor_direction: *tuple*
                directions of lazor
                x = 1 go right
                x = -1 go left
                y = 1 go down
                y = -1 go up

        returns:

            path_lazor: *list*
                all points that lazor passes

            path_block: *list*
                coordinates of all blocks that lazor passes

        '''

        path_lazor = []
        path_block = []

        x = lasor_position[0]
        y = lasor_position[1]

        x_dirct = lasor_direction[0]
        y_dirct = lasor_direction[1]

        path_lazor.append((x, y))

        next_pos = (x + x_dirct, y + y_dirct)

        while self.chk_lazor(next_pos):
            path_lazor.append(tuple(next_pos))

            if self.chk_block((x, next_pos[1])):
                path_block.append((x, next_pos[1]))
            elif self.chk_block((next_pos[0], y)):
                path_block.append((next_pos[0], y))

            x = next_pos[0]
            y = next_pos[1]

            next_pos[0] += x_dirct
            next_pos[1] += y_dirct
      
        return path_lazor, path_block
    

    def reflect(self, position, direction, blo_pos):
        '''
        This function finds the relection point the lazor direction after reflection

        parameters:

            position: *tuple*
                coordinates of lazor point

            direction: *tuple*
                directions of lazor

            blo_pos: *tuple*
                coordinates of lazor point

        return:

            new_dir: *tuple*
                directions of lazor after reflection

            ref_point: *tuple*
                coordinates of reflection point
        '''
        _, tmp_block = self.path(position, direction)

        if blo_pos not in tmp_block:
            return 'This block does not reflect!'
        


    def opaque(self, ):

    
    def refract(self, ):




